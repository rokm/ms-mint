{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MINT - Metabolomics Integrator MINT is a post-processing tool for liquid chromatography-mass spectrometry (LCMS) based metabolomics . Metabolomics is the study of all metabolites (small chemical compounds) in a biological sample e.g. from bacteria or a human blood sample. The metabolites can be used to define biomarkers used in medicine to find treatments for diseases or for the development of diagnostic tests or for the identification of pathogens such as methicillin resistant Staphylococcus aureus (MRSA). Figure 1: Flowchart of MINT processing workflow. How to use MINT? The tool can be used for targeted analysis where the m/z-values (mass to charge ratios) and chromatographic retention times are known. Alternatively, MINT can be used in an untargeted approach where new biomarkers can be explored without prior knowledge. MINT currently supports the open data formats mzML and mzXML. The main function is to extract and characterise measured intensities in a given m/z and retention time (RT) window. These windows can be provided in form of a peaklist or created interactively in the GUI . With this setup large numbers of LCMS-files can be processed automatically, standardized and perfectly reproducible. The tool can be used with a browser based graphical user interface (GUI) implemented as interactive dashboard with Plotly-Dash . Alternatively, the ms_mint package can be imported as python library to be integrated in any regular Python code as part of a larger processing pipeline or interacively in the Jupyter Notebook . Change cookie settings { .md-button }","title":"Home"},{"location":"#mint-metabolomics-integrator","text":"MINT is a post-processing tool for liquid chromatography-mass spectrometry (LCMS) based metabolomics . Metabolomics is the study of all metabolites (small chemical compounds) in a biological sample e.g. from bacteria or a human blood sample. The metabolites can be used to define biomarkers used in medicine to find treatments for diseases or for the development of diagnostic tests or for the identification of pathogens such as methicillin resistant Staphylococcus aureus (MRSA). Figure 1: Flowchart of MINT processing workflow.","title":"MINT - Metabolomics Integrator"},{"location":"#how-to-use-mint","text":"The tool can be used for targeted analysis where the m/z-values (mass to charge ratios) and chromatographic retention times are known. Alternatively, MINT can be used in an untargeted approach where new biomarkers can be explored without prior knowledge. MINT currently supports the open data formats mzML and mzXML. The main function is to extract and characterise measured intensities in a given m/z and retention time (RT) window. These windows can be provided in form of a peaklist or created interactively in the GUI . With this setup large numbers of LCMS-files can be processed automatically, standardized and perfectly reproducible. The tool can be used with a browser based graphical user interface (GUI) implemented as interactive dashboard with Plotly-Dash . Alternatively, the ms_mint package can be imported as python library to be integrated in any regular Python code as part of a larger processing pipeline or interacively in the Jupyter Notebook . Change cookie settings { .md-button }","title":"How to use MINT?"},{"location":"background/","text":"Background What is LCMS? A typical biological sample, such as human blood or agar with some kind of bacteria, can contain thousands of metabolites such as sugars, alcohols, amino acids, nucleotides and more. To meassure the composition of such a sample mass spectrometry can be used. However, many metabolites share exact masses with other metabolites and therefore would be undistiguishable in the mass spectrometer. Therefore, compounds are sorted using column chromatography and spread out over time. The metabolites that enter the column at the same time interact with the column in different ways based on their specific stereochemistry. These interactions let compounds move faster or slower through the column and therefore the compounds will elude at different times. That way various metabolites can be analysed successively over certain timeframe rather than simultaneously. The mass spectrometer that follows the chromatographic column meassures the masses given at each point in time and returns a time dependent spectrogram. An example of a LSMS meassurement is visualized in the following figure: Figure 1: A 2D-histogram of a MS1 recorded intensities taken over time span of 10 minutes. Shown are m/z values between 100 and 600 [Da/z]. If we zoom into this figure to a very narrow band of masses the traces of individual metabolites can be observed. The trace of succinate (or succinic acid ) is shown here: Figure 2: A zoom into the 2D histogram shown in figure 1. This illustrates how dense and precise the information in a LCMS messurement is. For comparison the M/Z value of an electron is 5.489e-4. Processing LCMS data After the data has been collected on a mass spectrometer (MS) and stored in a (usually) vendor specific format the data can be subjected to analysis. To process data with MINT the data has to be provided in an open format (mzML or mzXML). Instead of analysing the raw LCMS data it is common practise to deconvolute the data and sum up the signal of individual metabolites. The processed data should be proportional to the amount of metabolite in the sample. However, the meassured intensities will not reflect the relative concentrations between different compounds, only between different samples. For example, due to different ion efficiences compound A might have a stronger signal than compound B even if the compound B is present at higher concentration. Therefore, the intensities can only be use to compare relative amounts. To estimate absolute concentrations a calibration curve has to be created for every single metabolite. The binning transforms the semi-structured data into a structured format where each column stands for one particular metabolite. Often the data is normalized for each metabolite to reflect the relative intensities across multiple samples. The structured data can then be subjected to common data anayses such as dimensionality reduction, or clustering analysis. Figure 3: Clustering analysis for a small set of metabolites across 12 different samples including 3 different pathogens (EC: E. coli , SA: S. aureus , CA: C. albicans ).","title":"Background"},{"location":"background/#background","text":"","title":"Background"},{"location":"background/#what-is-lcms","text":"A typical biological sample, such as human blood or agar with some kind of bacteria, can contain thousands of metabolites such as sugars, alcohols, amino acids, nucleotides and more. To meassure the composition of such a sample mass spectrometry can be used. However, many metabolites share exact masses with other metabolites and therefore would be undistiguishable in the mass spectrometer. Therefore, compounds are sorted using column chromatography and spread out over time. The metabolites that enter the column at the same time interact with the column in different ways based on their specific stereochemistry. These interactions let compounds move faster or slower through the column and therefore the compounds will elude at different times. That way various metabolites can be analysed successively over certain timeframe rather than simultaneously. The mass spectrometer that follows the chromatographic column meassures the masses given at each point in time and returns a time dependent spectrogram. An example of a LSMS meassurement is visualized in the following figure: Figure 1: A 2D-histogram of a MS1 recorded intensities taken over time span of 10 minutes. Shown are m/z values between 100 and 600 [Da/z]. If we zoom into this figure to a very narrow band of masses the traces of individual metabolites can be observed. The trace of succinate (or succinic acid ) is shown here: Figure 2: A zoom into the 2D histogram shown in figure 1. This illustrates how dense and precise the information in a LCMS messurement is. For comparison the M/Z value of an electron is 5.489e-4.","title":"What is LCMS?"},{"location":"background/#processing-lcms-data","text":"After the data has been collected on a mass spectrometer (MS) and stored in a (usually) vendor specific format the data can be subjected to analysis. To process data with MINT the data has to be provided in an open format (mzML or mzXML). Instead of analysing the raw LCMS data it is common practise to deconvolute the data and sum up the signal of individual metabolites. The processed data should be proportional to the amount of metabolite in the sample. However, the meassured intensities will not reflect the relative concentrations between different compounds, only between different samples. For example, due to different ion efficiences compound A might have a stronger signal than compound B even if the compound B is present at higher concentration. Therefore, the intensities can only be use to compare relative amounts. To estimate absolute concentrations a calibration curve has to be created for every single metabolite. The binning transforms the semi-structured data into a structured format where each column stands for one particular metabolite. Often the data is normalized for each metabolite to reflect the relative intensities across multiple samples. The structured data can then be subjected to common data anayses such as dimensionality reduction, or clustering analysis. Figure 3: Clustering analysis for a small set of metabolites across 12 different samples including 3 different pathogens (EC: E. coli , SA: S. aureus , CA: C. albicans ).","title":"Processing LCMS data"},{"location":"developer-notes/","text":"Developer Notes python3 setup.py sdist bdist_wheel python3 -m twine upload --repository ms-mint dist/ms*mint-* Windows executables pyinstaller --onedir --noconfirm specfiles\\Mint__onedir__.spec --additional-hooks-dir=hooks Documentation deployment mkdocs build && mkdocs gh-deploy Example NGINX config location /mint/ { client_max_body_size 10G; proxy_pass http://localhost:9999; #rewrite ^/mint/(.*) /$1 break; proxy_http_version 1.1; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_read_timeout 86400; } Then start MINT with --serve-path='\\mint\\' . Additional packages To run tests and code optimization you need the following packages: conda install flake8 pytest mkdocs","title":"Developer Notes"},{"location":"developer-notes/#developer-notes","text":"python3 setup.py sdist bdist_wheel python3 -m twine upload --repository ms-mint dist/ms*mint-*","title":"Developer Notes"},{"location":"developer-notes/#windows-executables","text":"pyinstaller --onedir --noconfirm specfiles\\Mint__onedir__.spec --additional-hooks-dir=hooks","title":"Windows executables"},{"location":"developer-notes/#documentation-deployment","text":"mkdocs build && mkdocs gh-deploy","title":"Documentation deployment"},{"location":"developer-notes/#example-nginx-config","text":"location /mint/ { client_max_body_size 10G; proxy_pass http://localhost:9999; #rewrite ^/mint/(.*) /$1 break; proxy_http_version 1.1; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_read_timeout 86400; } Then start MINT with --serve-path='\\mint\\' .","title":"Example NGINX config"},{"location":"developer-notes/#additional-packages","text":"To run tests and code optimization you need the following packages: conda install flake8 pytest mkdocs","title":"Additional packages"},{"location":"docker/","text":"","title":"Docker"},{"location":"gallery/","text":"Gallery","title":"Gallery"},{"location":"gallery/#gallery","text":"","title":"Gallery"},{"location":"gui/","text":"MINT GUI Workspaces Add new workspaces Delete workspaces Activate workspace A workspace is a container for project files that is separated from other workspaces. Through workspaces it is possible to work on different projects simultaneously. All files relevant for one workspace are stored in a corresponding sub-folder of --data-dir , which by default is the folder MINT in the users home directory. The home directory is different on different platforms. Under Windows the default folder is: C:/Users/<username>/MINT . The path to the active workspace is always displayed above the workspace tab. To activate a particular workspace the workspace has to be selected in the table and then the ACTIVATE button has to be clicked. DELETE will display a popup window upon confirmation the selected workspace with all corresponding files on the harddrive in --data-dir will be removed. MS-files Import mass spectrometry files (MS-file) in mzXML or mzML format Convert file to feather format (other formats will be removed) Remove MS-files from workspace Mass-Spec files (in mzML or mzXML format) can be added under the MS-files tab by drag and drop or by using the selection form. Due to limitations of the Plotly-Dash framework only up to 10 files can be uploaded at a time. For larger projects, the files can simply be copied manually into the ms-files subdirectory. This will be improved in future versions of MINT. To remove certain files the files have to be selected in the table and the DELETE SELECTED FILES has to be clicked. The files are converted to feather format which is based on Apache Arrow. It is a representation that allows faster read into memory. If files were added manually by copying into the ms-files subdirectory the files can be converted to feather format with the CONVERT TO FEATHER button. Note that mzXML and mzML files will be deleted after convertion. Metadata Select samples used for peak optimization by setting values in the column PeakOpt to True . Add batch labels to analyse for possible batch effects. Add labels to analyse for differences of different groups (e.g. treatment and control) Add types for different files e.g. biological sample, quality control sample, standards etc in order to include ore exclude certain types during analysis. Add other types of metadata. Metadata for the individual files can be edited in the Metadata tab. This data can be used to group results e.g. by batch or by label as well as types. You want to edit metadata table to: Peaklist Import peaklist from CSV file or add new peaks manually Rename peaks definitions or change parameters Delete peak definitions Peaklists are collection of peak definitions for the extraction of MS intensities beloning to individual metabolites. Peaklists can be provided as Excel or CSV files. Peaklists are explained in more detail here . Files can be uploaded via the drag and drop area or the selection tool. The peaklist can be edited in place or with the peak optimization tools. Add Metabolites Search for metabolites from ChEBI three stars database Add selected metabolites to peaklist (without RT estimation) Peak Optimization Optimize retention times for all peaks or individual peaks Preview all peakshapes with quality indicator Retention times (RT) depend on the experiment and the specific chromatographic column used. Additionally, aging of the column leads to drifts in RT that have to be accounted for. The tools in the peak optimization tab can be used to quickly review all peak definitions in the presently loaded peaklist. The GENERATE PEAK PREVIEWS generates a preview of all peak definitions and plots the coresponding chromatograms for all files. The peaks can be reviewed and modified one by one with the interactive tool. FIND CLOSED PEAKS iterates through all peak definitions and identifes the closest peak with respect to the expected RT which is displayed as black vertical line. Manual (interactive) peak optimization Optimize individual peaks one by one Find bad peaks Remove peaks from peaklist Set expected retention time When a peak is selected in the drop down box the chromatograms for the particular mass windows using the peak width as defined in the peaklist is extracted and displayed. The current rt window is visualized as green box. SET RT TO CURRENT VIEW will set the rt_min and rt_max values to the current view and updated the peaklist accordingly. Processing Run MINT (apply the extraction protocol to all files in the workspace) Download results Reset results and start again When all peaks look good the data can be processed using RUN MINT . This will apply the current peaklist to the MS-files in the workspace and extract additional properties. When the results tables are present the results can be explored with the following tabs. The generated results can be downloaded with the DOWNLOAD button. Analysis After running MINT the results can be downloaed or analysed using the provided tools. For quality control purposes histograms and boxplots can be generated in the quality control tab. The interactive heatmap tool can be used to explore the results data after RUN MINT has been exectuted. The tool allows to explore the generated data in from of heatmaps. General selection elements Include/exclude file types (based on Type column in metadata) Include/exclude peak labels for analysis Set file sorting (e.g. by name, by batch etc.) Select group-by column for coloring and statistics Heatmap The first dropdown menu allows to include certain file types e.g. biological samples rather than quality control samples. The second dropdown menu distinguishes the how the heatmap is generated. Normalized by biomarer: devide values by column maxium. Cluster: Cluster rows with hierachical clustering. Dendrogram: Plots a dendrogram instead of row labels. Transpose: Switch columns and rows. Correlation: Calculate pearson correlation between columns. Show in new tab: The figure will be generated in a new independent tab. That way multiple heatmaps can be generated at the same time. Correlation of (scaled) peak_max Distributions Plot histograms Density distributions Boxplots The MS-files can be grouped based on the values in the metadata table. If nothing is selected the data will not be grouped in order to plot the overall distribution. The second dropdown menu allows to select one or multple kinds of graphs that to generate. The third dropdown menu allows to include certain file types. For example, the analysis can be limited to only the biological samples if such a type has been defined in the type column of the metadata table. The checkbox can be used to create a dense view. If the box is unchecked the output will be visually grouped into an individual section for each metabolite. PCA Perform Principal Component Analysis (PCA) Plot projections to first N principal components Contributions of original variables to each component. Hierarchical clustering Plotting MINT comes with a flexible and powerful plotting interface that is based on the powerful Seaborn library. Bar plots Violin plots Boxen plot Scatter plots and more...","title":"GUI"},{"location":"gui/#mint-gui","text":"","title":"MINT GUI"},{"location":"gui/#workspaces","text":"Add new workspaces Delete workspaces Activate workspace A workspace is a container for project files that is separated from other workspaces. Through workspaces it is possible to work on different projects simultaneously. All files relevant for one workspace are stored in a corresponding sub-folder of --data-dir , which by default is the folder MINT in the users home directory. The home directory is different on different platforms. Under Windows the default folder is: C:/Users/<username>/MINT . The path to the active workspace is always displayed above the workspace tab. To activate a particular workspace the workspace has to be selected in the table and then the ACTIVATE button has to be clicked. DELETE will display a popup window upon confirmation the selected workspace with all corresponding files on the harddrive in --data-dir will be removed.","title":"Workspaces"},{"location":"gui/#ms-files","text":"Import mass spectrometry files (MS-file) in mzXML or mzML format Convert file to feather format (other formats will be removed) Remove MS-files from workspace Mass-Spec files (in mzML or mzXML format) can be added under the MS-files tab by drag and drop or by using the selection form. Due to limitations of the Plotly-Dash framework only up to 10 files can be uploaded at a time. For larger projects, the files can simply be copied manually into the ms-files subdirectory. This will be improved in future versions of MINT. To remove certain files the files have to be selected in the table and the DELETE SELECTED FILES has to be clicked. The files are converted to feather format which is based on Apache Arrow. It is a representation that allows faster read into memory. If files were added manually by copying into the ms-files subdirectory the files can be converted to feather format with the CONVERT TO FEATHER button. Note that mzXML and mzML files will be deleted after convertion.","title":"MS-files"},{"location":"gui/#metadata","text":"Select samples used for peak optimization by setting values in the column PeakOpt to True . Add batch labels to analyse for possible batch effects. Add labels to analyse for differences of different groups (e.g. treatment and control) Add types for different files e.g. biological sample, quality control sample, standards etc in order to include ore exclude certain types during analysis. Add other types of metadata. Metadata for the individual files can be edited in the Metadata tab. This data can be used to group results e.g. by batch or by label as well as types. You want to edit metadata table to:","title":"Metadata"},{"location":"gui/#peaklist","text":"Import peaklist from CSV file or add new peaks manually Rename peaks definitions or change parameters Delete peak definitions Peaklists are collection of peak definitions for the extraction of MS intensities beloning to individual metabolites. Peaklists can be provided as Excel or CSV files. Peaklists are explained in more detail here . Files can be uploaded via the drag and drop area or the selection tool. The peaklist can be edited in place or with the peak optimization tools.","title":"Peaklist"},{"location":"gui/#add-metabolites","text":"Search for metabolites from ChEBI three stars database Add selected metabolites to peaklist (without RT estimation)","title":"Add Metabolites"},{"location":"gui/#peak-optimization","text":"Optimize retention times for all peaks or individual peaks Preview all peakshapes with quality indicator Retention times (RT) depend on the experiment and the specific chromatographic column used. Additionally, aging of the column leads to drifts in RT that have to be accounted for. The tools in the peak optimization tab can be used to quickly review all peak definitions in the presently loaded peaklist. The GENERATE PEAK PREVIEWS generates a preview of all peak definitions and plots the coresponding chromatograms for all files. The peaks can be reviewed and modified one by one with the interactive tool. FIND CLOSED PEAKS iterates through all peak definitions and identifes the closest peak with respect to the expected RT which is displayed as black vertical line.","title":"Peak Optimization"},{"location":"gui/#manual-interactive-peak-optimization","text":"Optimize individual peaks one by one Find bad peaks Remove peaks from peaklist Set expected retention time When a peak is selected in the drop down box the chromatograms for the particular mass windows using the peak width as defined in the peaklist is extracted and displayed. The current rt window is visualized as green box. SET RT TO CURRENT VIEW will set the rt_min and rt_max values to the current view and updated the peaklist accordingly.","title":"Manual (interactive) peak optimization"},{"location":"gui/#processing","text":"Run MINT (apply the extraction protocol to all files in the workspace) Download results Reset results and start again When all peaks look good the data can be processed using RUN MINT . This will apply the current peaklist to the MS-files in the workspace and extract additional properties. When the results tables are present the results can be explored with the following tabs. The generated results can be downloaded with the DOWNLOAD button.","title":"Processing"},{"location":"gui/#analysis","text":"After running MINT the results can be downloaed or analysed using the provided tools. For quality control purposes histograms and boxplots can be generated in the quality control tab. The interactive heatmap tool can be used to explore the results data after RUN MINT has been exectuted. The tool allows to explore the generated data in from of heatmaps.","title":"Analysis"},{"location":"gui/#general-selection-elements","text":"Include/exclude file types (based on Type column in metadata) Include/exclude peak labels for analysis Set file sorting (e.g. by name, by batch etc.) Select group-by column for coloring and statistics","title":"General selection elements"},{"location":"gui/#heatmap","text":"The first dropdown menu allows to include certain file types e.g. biological samples rather than quality control samples. The second dropdown menu distinguishes the how the heatmap is generated. Normalized by biomarer: devide values by column maxium. Cluster: Cluster rows with hierachical clustering. Dendrogram: Plots a dendrogram instead of row labels. Transpose: Switch columns and rows. Correlation: Calculate pearson correlation between columns. Show in new tab: The figure will be generated in a new independent tab. That way multiple heatmaps can be generated at the same time.","title":"Heatmap"},{"location":"gui/#correlation-of-scaled-peak_max","text":"","title":"Correlation of (scaled) peak_max"},{"location":"gui/#distributions","text":"Plot histograms Density distributions Boxplots The MS-files can be grouped based on the values in the metadata table. If nothing is selected the data will not be grouped in order to plot the overall distribution. The second dropdown menu allows to select one or multple kinds of graphs that to generate. The third dropdown menu allows to include certain file types. For example, the analysis can be limited to only the biological samples if such a type has been defined in the type column of the metadata table. The checkbox can be used to create a dense view. If the box is unchecked the output will be visually grouped into an individual section for each metabolite.","title":"Distributions"},{"location":"gui/#pca","text":"Perform Principal Component Analysis (PCA) Plot projections to first N principal components Contributions of original variables to each component.","title":"PCA"},{"location":"gui/#hierarchical-clustering","text":"","title":"Hierarchical clustering"},{"location":"gui/#plotting","text":"MINT comes with a flexible and powerful plotting interface that is based on the powerful Seaborn library. Bar plots Violin plots Boxen plot Scatter plots and more...","title":"Plotting"},{"location":"install/","text":"Installation Installation with PIP (Linux, MacOS, Windows) The latest release of the program can easily be installed in a standard Python 3 (>= 3.7) environment using the widely used package manager pip : pip install ms-mint Should download and install all necessary dependencies and Mint. Mint should then be available via Mint.py Windows Installer For Windows 10 a build is provided here . The installer generates an icon in the windows start menu. There will be a terminal be shown, with potentially some errors due to missing files which can be ignored. Give it some time until the server is running and then navigate to http://localhost:9999 in the browser. Start Mint.py After installation MINT can be started by running Mint.py . Mint.py --help usage: Mint.py [-h] [--no-browser] [--version] [--data-dir DATA_DIR] [--debug] [--port PORT] [--serve-path SERVE_PATH] MINT frontend. optional arguments: -h, --help show this help message and exit --no-browser do not start the browser --version print current version --data-dir target directory for MINT data --debug start MINT server in debug mode --port change the port --serve-path serve app at a different path e.g. '/mint/' to serve the app at 'localhost:9999/mint/' If the browser does not open automatically open it manually and navigate to http://localhost:9999 . The app's frontend is build using Plotly-Dash and runs locally in a browser. Thought, the Python functions provided can be imported and used in any Python project independently. The GUI is under active development and may be optimized in the future. Docker MINT is now available on DockerHub in containerized format. A container is a standard unit of software that packages up code and all its dependencies, so the application runs quickly and reliably from one computing environment to another. In contrast to a virtual machine (VM), a Docker container image is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings. This allows to run MINT on any computer that can run Docker. The following command can be used to pull the latest image from docker hub. docker pull msmint/msmint:latest The image can be started with: docker run -p 9999:9999 -it msmint/msmint:latest -v /data/:/data/ Then the tool is available in the browser at http://localhost:9999. From source Here we use conda from the miniconda package to install dependencies in a virtual environment. git clone https://github.com/soerendip/ms-mint cd ms-mint conda create -n ms-mint python=3.8 conda activate ms-mint pip setup.py install # for regular install pip install -e . # for development","title":"Installation"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#installation-with-pip-linux-macos-windows","text":"The latest release of the program can easily be installed in a standard Python 3 (>= 3.7) environment using the widely used package manager pip : pip install ms-mint Should download and install all necessary dependencies and Mint. Mint should then be available via Mint.py","title":"Installation with PIP (Linux, MacOS, Windows)"},{"location":"install/#windows-installer","text":"For Windows 10 a build is provided here . The installer generates an icon in the windows start menu. There will be a terminal be shown, with potentially some errors due to missing files which can be ignored. Give it some time until the server is running and then navigate to http://localhost:9999 in the browser.","title":"Windows Installer"},{"location":"install/#start-mintpy","text":"After installation MINT can be started by running Mint.py . Mint.py --help usage: Mint.py [-h] [--no-browser] [--version] [--data-dir DATA_DIR] [--debug] [--port PORT] [--serve-path SERVE_PATH] MINT frontend. optional arguments: -h, --help show this help message and exit --no-browser do not start the browser --version print current version --data-dir target directory for MINT data --debug start MINT server in debug mode --port change the port --serve-path serve app at a different path e.g. '/mint/' to serve the app at 'localhost:9999/mint/' If the browser does not open automatically open it manually and navigate to http://localhost:9999 . The app's frontend is build using Plotly-Dash and runs locally in a browser. Thought, the Python functions provided can be imported and used in any Python project independently. The GUI is under active development and may be optimized in the future.","title":"Start Mint.py"},{"location":"install/#docker","text":"MINT is now available on DockerHub in containerized format. A container is a standard unit of software that packages up code and all its dependencies, so the application runs quickly and reliably from one computing environment to another. In contrast to a virtual machine (VM), a Docker container image is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings. This allows to run MINT on any computer that can run Docker. The following command can be used to pull the latest image from docker hub. docker pull msmint/msmint:latest The image can be started with: docker run -p 9999:9999 -it msmint/msmint:latest -v /data/:/data/ Then the tool is available in the browser at http://localhost:9999.","title":"Docker"},{"location":"install/#from-source","text":"Here we use conda from the miniconda package to install dependencies in a virtual environment. git clone https://github.com/soerendip/ms-mint cd ms-mint conda create -n ms-mint python=3.8 conda activate ms-mint pip setup.py install # for regular install pip install -e . # for development","title":"From source"},{"location":"jupyter/","text":"Jupyter integration Interactive MINT MINT can be used interactively in a Jupyter Notebook with a GUI that is based on IPython-Widgets or programmatically. from ms_mint.notebook import Mint mint = Mint(verbose=False) mint.show() With the JupyterLab it is possible to customize the GUI to personal needs. A demo notebook is available here . Select MS-files from glob import glob mint.ms_files = glob('/path/to/files/*mzML') Select peaklist files mint.peaklist_files = '/path/to/peaklist/file/peaklist.csv' Optimize retention times mint.optimize_retention_times() Run MINT mint.run() Display results That way the results will be readily available for further analysis. mint.results","title":"Jupyter"},{"location":"jupyter/#jupyter-integration","text":"","title":"Jupyter integration"},{"location":"jupyter/#interactive-mint","text":"MINT can be used interactively in a Jupyter Notebook with a GUI that is based on IPython-Widgets or programmatically. from ms_mint.notebook import Mint mint = Mint(verbose=False) mint.show() With the JupyterLab it is possible to customize the GUI to personal needs. A demo notebook is available here .","title":"Interactive MINT"},{"location":"jupyter/#select-ms-files","text":"from glob import glob mint.ms_files = glob('/path/to/files/*mzML')","title":"Select MS-files"},{"location":"jupyter/#select-peaklist-files","text":"mint.peaklist_files = '/path/to/peaklist/file/peaklist.csv'","title":"Select peaklist files"},{"location":"jupyter/#optimize-retention-times","text":"mint.optimize_retention_times()","title":"Optimize retention times"},{"location":"jupyter/#run-mint","text":"mint.run()","title":"Run MINT"},{"location":"jupyter/#display-results","text":"That way the results will be readily available for further analysis. mint.results","title":"Display results"},{"location":"peak-detection/","text":"Peak detection Peak detection is still an experimental feature. Internally, OpenMS's algorithm for peak detection from metabolomics data 'FeatureFindingMetabo' is used to detect peaks in two steps. First, each MS file is scanned for potential peaks with the OpenMS algorithm. Then similar peaks across multiple files are merged. Peak alignment for retention time drift correction is omitted. The feature maps that are internally stored in OpenMS format (featureXML) are then transformed to table format that is used by MINT. However, the detected features often come from contaminations. Additional scoring and pre-filtering is recommended to filter out low quality peak definitions which is currently investigated. The controllable parameters for the detection algorithm are the minimum OpenMS peak quality and the maximum number of peaks per file. In the Jupter Notebook feature detection can be done as demonstrated in the following: %pylab inline from ms_mint.notebook import Mint from glob import glob mint = Mint() mint.show() mint.ms_files = [list-of-filenames] mint.detect_peaks(min_quality=1e-3, condensed=True, max_delta_mz_ppm=10, max_delta_rt=0.1)","title":"Peak detection"},{"location":"peak-detection/#peak-detection","text":"Peak detection is still an experimental feature. Internally, OpenMS's algorithm for peak detection from metabolomics data 'FeatureFindingMetabo' is used to detect peaks in two steps. First, each MS file is scanned for potential peaks with the OpenMS algorithm. Then similar peaks across multiple files are merged. Peak alignment for retention time drift correction is omitted. The feature maps that are internally stored in OpenMS format (featureXML) are then transformed to table format that is used by MINT. However, the detected features often come from contaminations. Additional scoring and pre-filtering is recommended to filter out low quality peak definitions which is currently investigated. The controllable parameters for the detection algorithm are the minimum OpenMS peak quality and the maximum number of peaks per file. In the Jupter Notebook feature detection can be done as demonstrated in the following: %pylab inline from ms_mint.notebook import Mint from glob import glob mint = Mint() mint.show() mint.ms_files = [list-of-filenames] mint.detect_peaks(min_quality=1e-3, condensed=True, max_delta_mz_ppm=10, max_delta_rt=0.1)","title":"Peak detection"},{"location":"python/","text":"Python API The MINT API for Python can be imported as a python object and used in a python script or interactively in a Jupyter notebook environment. A typical workflow using the Python API is described in the following: from ms_mint import Mint from glob import glob Fist, the Mint class has to be instantiated: mint = Mint(verbose=False) Load files One ore more peaklist files as well as mass-spec files have to be assigned to mint.peaklist_files and mint.files accordingly: mint.peaklist_files = ['path_to/peaklist-file.csv'] mint.files = glob('path_to/ms-files/*/**.mzML', recursive=True) Calling the peaklist() method displays the imported and concatenated peaklists: print(mint.peaklist) peak_label mz_mean mz_width rt_min rt_max intensity_threshold peaklist 0 1 151.06050 5 5.07 5.09 0 ./data/peaklist_v0.csv 1 2 216.05040 5 3.98 4.39 0 ./data/peaklist_v0.csv 2 3 115.00320 5 3.45 4.39 0 ./data/peaklist_v0.csv 3 4 273.00061 5 1.10 2.22 0 ./data/peaklist_v0.csv Running Mint Then mint can be executed calling the run() method: mint.run() > Run MINT > Total runtime: 6.18s > Runtime per file: 3.09s > Runtime per peak (79): 0.04s Results The result will be stored in the results and the crosstab attributes as pandas.DataFrames() . Where mint.results contains all results: print(mint.results) peak_label mz_mean mz_width rt_min rt_max intensity_threshold peaklist peak_area ms_file ms_path file_size intensity_sum 1 151.06050 5 5.07 5.09 0 ./data/peaklist_v0.csv 2.879748e+03 ./data/test.mzXML ./data 14.201964 5.607296e+10 2 216.05040 5 3.98 4.39 0 ./data/peaklist_v0.csv 4.892307e+05 ./data/test.mzXML ./data 14.201964 5.607296e+10 3 115.00320 5 3.45 4.39 0 ./data/peaklist_v0.csv 3.916772e+07 ./data/test.mzXML ./data 14.201964 5.607296e+10 4 273.00061 5 1.10 2.22 0 ./data/peaklist_v0.csv 6.862484e+06 ./data/test.mzXML ./data 14.201964 5.607296e+10 1 151.06050 5 5.07 5.09 0 ./data/peaklist_v0.csv 2.879748e+03 ./data/test.mzXML ./data 14.201964 5.607296e+10 2 216.05040 5 3.98 4.39 0 ./data/peaklist_v0.csv 4.892307e+05 ./data/test.mzXML ./data 14.201964 5.607296e+10 3 115.00320 5 3.45 4.39 0 ./data/peaklist_v0.csv 3.916772e+07 ./data/test.mzXML ./data 14.201964 5.607296e+10 4 273.00061 5 1.10 2.22 0 ./data/peaklist_v0.csv 6.862484e+06 ./data/test.mzXML ./data 14.201964 5.607296e+10 and crosstab() can shows a compressed form of the data only containing one property e.g. the extracted peak_area : ... Peak shapes The last property is mint.rt_projections which stores a dictionary of dictionaries with peak shapes: {'1': {'./data/test.mzXML': retentionTime 5.079267 2879.747559 dtype: float32}, '2': {'./data/test.mzXML': retentionTime 3.986050 15166.202148 3.996917 14039.182617 4.007817 15455.113281 4.018700 16612.851562 4.029633 22065.619141 4.040633 26693.970703 4.051533 22569.896484 4.062450 32379.552734 4.073567 27225.439453 4.084683 22142.037109 4.095867 22974.357422 4.106900 23733.207031 4.117917 25081.419922 4.128983 17945.343750 4.140200 14623.268555 4.151250 16119.997070 4.162317 15771.708008 4.173467 11171.838867 4.184517 12554.623047 ... Plotting peak shapes The peak shapes can be plotted with the same function that is used by the GUI's: from ms_mint.plotly_tools import plot_rt_projections plot_rt_projections(mint) Export Mint results can be exported using the export() method. A filename has to be provided: mint.export('MINT-results.xlsx') An Excel file with the results is exported. The file includes the data of all windows that were used as well as some metadata such as date and the current verion of Mint .","title":"Python API"},{"location":"python/#python-api","text":"The MINT API for Python can be imported as a python object and used in a python script or interactively in a Jupyter notebook environment. A typical workflow using the Python API is described in the following: from ms_mint import Mint from glob import glob Fist, the Mint class has to be instantiated: mint = Mint(verbose=False)","title":"Python API"},{"location":"python/#load-files","text":"One ore more peaklist files as well as mass-spec files have to be assigned to mint.peaklist_files and mint.files accordingly: mint.peaklist_files = ['path_to/peaklist-file.csv'] mint.files = glob('path_to/ms-files/*/**.mzML', recursive=True) Calling the peaklist() method displays the imported and concatenated peaklists: print(mint.peaklist) peak_label mz_mean mz_width rt_min rt_max intensity_threshold peaklist 0 1 151.06050 5 5.07 5.09 0 ./data/peaklist_v0.csv 1 2 216.05040 5 3.98 4.39 0 ./data/peaklist_v0.csv 2 3 115.00320 5 3.45 4.39 0 ./data/peaklist_v0.csv 3 4 273.00061 5 1.10 2.22 0 ./data/peaklist_v0.csv","title":"Load files"},{"location":"python/#running-mint","text":"Then mint can be executed calling the run() method: mint.run() > Run MINT > Total runtime: 6.18s > Runtime per file: 3.09s > Runtime per peak (79): 0.04s","title":"Running Mint"},{"location":"python/#results","text":"The result will be stored in the results and the crosstab attributes as pandas.DataFrames() . Where mint.results contains all results: print(mint.results) peak_label mz_mean mz_width rt_min rt_max intensity_threshold peaklist peak_area ms_file ms_path file_size intensity_sum 1 151.06050 5 5.07 5.09 0 ./data/peaklist_v0.csv 2.879748e+03 ./data/test.mzXML ./data 14.201964 5.607296e+10 2 216.05040 5 3.98 4.39 0 ./data/peaklist_v0.csv 4.892307e+05 ./data/test.mzXML ./data 14.201964 5.607296e+10 3 115.00320 5 3.45 4.39 0 ./data/peaklist_v0.csv 3.916772e+07 ./data/test.mzXML ./data 14.201964 5.607296e+10 4 273.00061 5 1.10 2.22 0 ./data/peaklist_v0.csv 6.862484e+06 ./data/test.mzXML ./data 14.201964 5.607296e+10 1 151.06050 5 5.07 5.09 0 ./data/peaklist_v0.csv 2.879748e+03 ./data/test.mzXML ./data 14.201964 5.607296e+10 2 216.05040 5 3.98 4.39 0 ./data/peaklist_v0.csv 4.892307e+05 ./data/test.mzXML ./data 14.201964 5.607296e+10 3 115.00320 5 3.45 4.39 0 ./data/peaklist_v0.csv 3.916772e+07 ./data/test.mzXML ./data 14.201964 5.607296e+10 4 273.00061 5 1.10 2.22 0 ./data/peaklist_v0.csv 6.862484e+06 ./data/test.mzXML ./data 14.201964 5.607296e+10 and crosstab() can shows a compressed form of the data only containing one property e.g. the extracted peak_area : ...","title":"Results"},{"location":"python/#peak-shapes","text":"The last property is mint.rt_projections which stores a dictionary of dictionaries with peak shapes: {'1': {'./data/test.mzXML': retentionTime 5.079267 2879.747559 dtype: float32}, '2': {'./data/test.mzXML': retentionTime 3.986050 15166.202148 3.996917 14039.182617 4.007817 15455.113281 4.018700 16612.851562 4.029633 22065.619141 4.040633 26693.970703 4.051533 22569.896484 4.062450 32379.552734 4.073567 27225.439453 4.084683 22142.037109 4.095867 22974.357422 4.106900 23733.207031 4.117917 25081.419922 4.128983 17945.343750 4.140200 14623.268555 4.151250 16119.997070 4.162317 15771.708008 4.173467 11171.838867 4.184517 12554.623047 ...","title":"Peak shapes"},{"location":"python/#plotting-peak-shapes","text":"The peak shapes can be plotted with the same function that is used by the GUI's: from ms_mint.plotly_tools import plot_rt_projections plot_rt_projections(mint)","title":"Plotting peak shapes"},{"location":"python/#export","text":"Mint results can be exported using the export() method. A filename has to be provided: mint.export('MINT-results.xlsx') An Excel file with the results is exported. The file includes the data of all windows that were used as well as some metadata such as date and the current verion of Mint .","title":"Export"},{"location":"targets/","text":"Target lists A target list contains the definitions of peaks to be extracted in terms of retention time and mz value. The important parameters for MINT are rt_min and rt_max . The rt value is only used as an estimate and used for comparison. You should know, from former identification runs, at what retention time to expect a certain metabolite. This is what rt is for. For the final extraction process however rt_min and rt_max are used. Before you process the MS files, you should check that all targts have rt_min and rt_max properly set. Target list format The target list is the determining protocol for the data processing step. You can reproduce all results using this list as input. A target list can be provided as csv (comma separated values) or xlsx (Microsoft Excel) file. If the preaklist is provided as multi-sheet xlsx file the target list should be the first sheet. The input files contains a number of columns headers in the target list should contain: peak_label : A unique identifier such as the biomarker name or ID. Even if multiple peaklist files are used, the label have to be unique across all the files. mz_mean : The target mass (m/z-value) in [Da]. mz_width : The width of the peak in the m/z-dimension in units of ppm. The window will be mz_mean +/- (mz_width * mz_mean * 1e-6). Usually, a values between 5 and 10 are used. rt : Estimated retention time in [min] (optional, see above). rt_min : The start of the retention time for each peak in [min]. rt_max : The end of the retention time for each peak in [min]. intensity_threshold : A threshold that is applied to filter noise for each window individually. Can be set to 0 or any positive value. Example file target.csv: peak_label,mz_mean,mz_width,rt_min,rt_max,intensity_threshold Biomarker-A,151.0605,10,4.65,5.2,0 Biomarker-B,151.02585,10,4.18,4.53,0 A template can be created using the GUI .","title":"Targets"},{"location":"targets/#target-lists","text":"A target list contains the definitions of peaks to be extracted in terms of retention time and mz value. The important parameters for MINT are rt_min and rt_max . The rt value is only used as an estimate and used for comparison. You should know, from former identification runs, at what retention time to expect a certain metabolite. This is what rt is for. For the final extraction process however rt_min and rt_max are used. Before you process the MS files, you should check that all targts have rt_min and rt_max properly set.","title":"Target lists"},{"location":"targets/#target-list-format","text":"The target list is the determining protocol for the data processing step. You can reproduce all results using this list as input. A target list can be provided as csv (comma separated values) or xlsx (Microsoft Excel) file. If the preaklist is provided as multi-sheet xlsx file the target list should be the first sheet. The input files contains a number of columns headers in the target list should contain: peak_label : A unique identifier such as the biomarker name or ID. Even if multiple peaklist files are used, the label have to be unique across all the files. mz_mean : The target mass (m/z-value) in [Da]. mz_width : The width of the peak in the m/z-dimension in units of ppm. The window will be mz_mean +/- (mz_width * mz_mean * 1e-6). Usually, a values between 5 and 10 are used. rt : Estimated retention time in [min] (optional, see above). rt_min : The start of the retention time for each peak in [min]. rt_max : The end of the retention time for each peak in [min]. intensity_threshold : A threshold that is applied to filter noise for each window individually. Can be set to 0 or any positive value.","title":"Target list format"},{"location":"targets/#example-file","text":"target.csv: peak_label,mz_mean,mz_width,rt_min,rt_max,intensity_threshold Biomarker-A,151.0605,10,4.65,5.2,0 Biomarker-B,151.02585,10,4.18,4.53,0 A template can be created using the GUI .","title":"Example file"}]}